---
layout: post
title: (Go) 4. 자료형
categories:
  - Language-Go
---

**본 글은 Kakao Enterprise 예비인턴 GOLang 교육내용 및 자습/과제를 정리한 내용입니다.**

> [Github Source Code - Gotour](https://github.com/TakeaimK/Gotour){: target="\_blank"}

# A tour of Go

A tour of Go는 Golang의 특징을 공부할 수 있는 학습 사이트이다.
한국어 사이트와 영어 사이트가 있으며, 내용은 거의 동일하다.

> [gotour - 한국어](https://go-tour-kr.appspot.com/#24){: target="\_blank"}  
> [gotour - 영어](https://tour.golang.org/moretypes/1){: target="\_blank"}

---

## 기본 자료형

```
Go의 기본 자료형은 아래와 같습니다.

bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8의 다른 이름(alias)

rune // int32의 다른 이름(alias)
     // 유니코드 코드 포인트 값을 표현합니다.

float32 float64

complex64 complex128
```

```go
package main

import (
    "fmt"
    "math/cmplx"
)

var (
    ToBe   bool       = false
    MaxInt uint64     = 1<<64 - 1
    z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
    const f = "%T(%v)\n"
    fmt.Printf(f, ToBe, ToBe)
    fmt.Printf(f, MaxInt, MaxInt)
    fmt.Printf(f, z, z)
}


```

정수형을 가만히 살펴보면 short, long 같이 다른 언어에서 자주 볼 수 있던 자료형 대신, int8, int16, int32 등의 int로 통합되어 있다.  
실수도 마찬가지로, dobule 없이 float32, float64를 사용하여 파편화를 줄였다.  
위 자료형에 대해 표로 정리해 보았다.

|:--:|:--:|:--:|
|자료형|설명|저장범위|
|uint|32비트 시스템에서는 uint32, 64비트 시스템에서는 uint64||
|uint8|부호 없는 8비트 정수형|0 ~ 255 (1<<8 -1)|
|uint16|부호 없는 16비트 정수형|0 ~ 65,535 (1<<16 -1)|
|unit32|부호 없는 32비트 정수형|0 ~ 4,294,967,295 (1<<32 -1)|
|uint64|부호 없는 64비트 정수형|0 ~ 18,446,744,073,709,551,615 (1<<64 -1)|
|int|32비트 시스템에서는 int32, 64비트 시스템에서는 int64||
|int8|부호 있는 8비트 정수형|-128 ~ 127|
|int16|부호 있는 16비트 정수형|-32,768 ~ 32,767|
|int32|부호 있는 32비트 정수형|-2,147,483,648 ~ 2,147,483,647|
|int64|부호 있는 64비트 정수형|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807|

|자료형|설명|
|float32|IEEE-754 32비트 부동소수점, 7자리 정밀도|
|float64|IEEE-754 64비트 부동소수점, 12자리 정밀도|
|complex64|float32 크기의 실수부와 허수부로 구성된 복소수|
|complex128|float64 크기의 실수부와 허수부로 구성된 복소수|
|uintptr|uint와 같은 크기를 갖는 포인터형|
|bool|참, 거짓을 표현하기 위한 8비트 자료형|
|byte|8비트 자료형|
|rune|유니코드 저장을 위한 자료형, 크기는 int32와 동일|
|string|문자열을 저장하기 위한 자료형|

---

## 구조체 (Structs)

```
struct 는 필드(데이터)들의 조합입니다.

(그리고 type 선언으로 struct의 이름을 지정할 수 있습니다.)
```

```go
package main

import "fmt"

type Vertex struct {
    X int
    Y int
    str string
}

func main() {
    fmt.Println(Vertex{1, 2, "Hello world!"})
}

```

Golang에는 클래스 개념이 없고, 대신 C처럼 구조체가 있다. type 키워드는 나중에 interface에도 사용되고, 더 넓게는 직접 자료형을 제작하여 사용할 수도 있다. 아래와 같이 말이다.

```go
type Mystring string
var myStr Mystring = Mystring("awesome")
var str string = string(myStr)
```

---

```
구조체에 속한 필드(데이터)는 dot(.) 으로 접근합니다.
```

```go
package main

import "fmt"

type Vertex struct {
    X int
    Y int
}

func main() {
    v := Vertex{1, 2}
    fmt.Println(v)
    v.X = 4
    fmt.Println(v)
    v.Y = 8
    fmt.Println(v.X + v.Y)
}


```

`fmt.Println()` 처럼 구조체 내부 항목에 접근할 때 `.` 기호를 사용한다.  
만약 다른 패키지에서 구조체 내부의 항목에 접근해서 안 되는 변수가 있다면 소문자로 시작하여 선언한다.

---

## 포인터 (Pointer)

```
Go에는 포인터가 있지만 포인터 연산은 불가능합니다.

구조체 변수는 구조체 포인터를 이용해서 접근 할 수 있습니다.

포인터를 이용하는 간접적인 접근은 실제 구조체에도 영향을 미칩니다.
```

```go
package main

import "fmt"

type Vertex struct {
    X int
    Y int
}

func main() {
    p := Vertex{1, 2}
    q := &p
    fmt.Println(q)	//&{1 2}
    q.X = 1e9
    fmt.Println(p)	//{1000000000 2}
}



```

사담이지만, 개인적으로는 포인터가 좀 무섭다. System Programming 과목에서 C언어로 Key-Value Store 제작 프로젝트를 하다 무엇을 잘못 건드렸는지 포인터가 메모리의 내장 그래픽으로 할당된 영역을 침범한 것으로 추정되는 경우가 발생해서 화면이 초록초록하게(...?) 질려버리며 다운되는 경우도 있었고, 암튼 포인터를 쓰면서 좋은 기억은 없다.

아무튼, Go에는 포인터가 있지만 포인터 연산은 지원하지 않기에, 정말 "포인터"로서 역할을 수행한다. C처럼 주소 번지를 출력하는 게 아니라, 정말 "{1 2}를 가리킴" 이라고 출력해 준다. ~~뭔가 마음이 편안~~

---

## 구조체 리터럴 (Struct Literals)

```
구조체 리터럴은 필드와 값을 나열해서 구조체를 새로 할당하는 방법입니다.

원하는 필드를 `{Name: value}` 구문을 통해 할당할 수 있습니다. (필드의 순서는 상관 없습니다.)

특별한 접두어 & 를 사용하면 구조체 리터럴에 대한 포인터를 생성할 수 있습니다.
```

```go
package main

import (
    "fmt"
    "math"
)

func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v < lim {
		//v += 1 //<=가능함!
        return v
    }
    return lim
}

func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}


```

`math.Pow(x,y)`는 x의 y승을 계산해 주는 함수이다. 조건문 안에서 계산하여 세미콜론으로 문장을 구분지어 비교가 가능하다.

---

```
if 에서 짧은 명령문을 통해 선언된 변수는 else 블럭 안에서도 사용할 수 있습니다.
```

```go
package main

import (
    "fmt"
    "math"
)

func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v < lim {
        return v
    } else {
        fmt.Printf("%g >= %g\n", v, lim)
    }
    // can't use v here, though
    return lim
}

func main() {
    fmt.Println(
        pow(3, 2, 10),
        pow(3, 3, 20),
    )
}


```

if에서 선언된 조건문에 사용된 변수는, else에서도 활용이 가능하다. if와 else는 서로 뗄 수 없는 관계이며, 그래서 if 블록 다음 else를 바로 붙여 적어야 하게 만들었다는 느낌을 받는다.

```
함수와 루프의 사용법을 익히는 간단한 연습으로, 제곱근 함수를 뉴턴의 방법(Newton's method)을 이용하여 구현합니다.

여기서 뉴턴의 방법이란 초기값 z를 선택한 후에 다음의 공식을 이용하여 반복적으로 Sqrt(x) 함수의 근사값을 찾아가는 방법을 말합니다:

z = z - (z * z - x) / (2 * z)

처음에는 계산을 10번만 반복하여 여러분이 작성한 함수가 다양한 값들 (1, 2, 3, ...)에 대하여 얼마나 정확한 값을 찾아내는지 확인합니다.

그 다음에는, 루프의 조건을 수정하여 값이 더이상 바뀌지 않을 때 (혹은 아주 작은 차이가 발생할 때) 루프를 종료하도록 합니다. 이렇게 하면 반복문의 실행 횟수가 어떻게 달라지는지 확인합니다. 결과값이 math.Sqrt 함수의 값과 얼마나 비슷한가요?

힌트: 실수(floating point)값을 선언하고 초기화 하려면, 실수값을 표현하는 문법을 사용하거나 변환 함수를 사용합니다:
z := float64(1)
z := 1.0
```

```go
package main

import (
    "fmt"
    "math"
)

func Sqrt1(x float64, r int) float64 {
    z := float64(1)

    for i:=0; i<r; i++{
        z = z-(z*z-x)/(2*z)
    }
    return z
}

func Sqrt2(x float64) float64{
    z := float64(1)

    for {
        result := z-(z*z-x)/(2*z)

        if float64(result) == float64(z) {
                return result
        }
        z = result
    }
}

func main() {
    var num float64
    var rng int
    fmt.Print("Sqrt number : ")
    fmt.Scan(&num)
    fmt.Print("range : ")
    fmt.Scan(&rng)
    fmt.Println(Sqrt1(num, rng))
    fmt.Println(Sqrt2(num))
    fmt.Println(math.Sqrt(num))
}

```

뉴턴-랩슨의 방법에 대해서 자세히 알고 싶다면 [제곱근 구하기 - 바빌로니아, 뉴턴-랩슨 방법](https://dowhati1.tistory.com/m/31?category=722279){: target="\_blank"} 링크를 참조하자.  
우선 제곱근을 구할 수를 입력받고, Sqrt1 함수에서 반복할 횟수를 입력받는다. 그러면 (1)뉴턴-랩슨 방법에서 지정된 횟수만큼 돌린 값, (2)컴퓨터 계산으로 동일하다고 판단될 때까지 반복하며 돌린 값, (3)`math.Sqrt`를 사용한 값 순서로 출력한다.  
결과는 다음과 같다.

```
Sqrt number : 10
range : 1
5.5
3.1622776601683795
3.1622776601683795

Sqrt number : 10
range : 2
3.659090909090909
3.1622776601683795
3.1622776601683795

Sqrt number : 10
range : 3
3.196005081874647
3.1622776601683795
3.1622776601683795

Sqrt number : 10
range : 4
3.1624556228038903
3.1622776601683795
3.1622776601683795

Sqrt number : 10
range : 5
3.162277665175675
3.1622776601683795
3.1622776601683795

Sqrt number : 10
range : 6
3.1622776601683795
3.1622776601683795
3.1622776601683795
```

10의 제곱근을 구하고자 한다면, 6회를 돌려야 동일하게 나온다는 것을 알 수 있다. 무한루프를 돌린 값과 `math.Sqrt` 값은 같다. 즉, math 라이브러리에 있는 sqrt 함수와 거의 동일하다.  
실제 `math.Sqrt`는 다음과 같다.
[Source file src/math/sqrt.go](https://golang.org/src/math/sqrt.go)

---

## 조건문 (Switch) - Eng ver에만 존재

```
Switch 문은 if-else 문의 순서를 작성하는 더 짧은 방법이다. 값이 조건식과 같은 첫 번째 경우를 실행한다.
Go의 스위치는 C, C++, Java, Javascript, PHP의 Switch와 같으나, break 문이 필요 없이 선택된 항목에 대해서만 실행된다.
또 다른 중요한 점은, Switch의 case 값이 꼭 상수가 아니어도 되고, 관련 값은 정수가 아니어도 된다.
```

```go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
	}
}

```

Go 언어의 switch는 break문이 필요 없다. 알아서 case에 걸리면 해당 case만 실행하고 switch문을 탈출한다. 더욱이, case 자리에 문자열이나 함수의 결과값이 들어가도 된다!

---

```
switch문은 위에서 아래로 훑으며 case에 걸리면 나머지 case는 진행하지 않는다.

(예를 들어,

switch i {
case 0:
case f():
}
i==0이면 f는 부르지 않음)

```

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("When's Saturday?")
	today := time.Now().Weekday()
	switch time.Saturday {
	case today + 0:
		fmt.Println("Today.")
	case today + 1:
		fmt.Println("Tomorrow.")
	case today + 2:
		fmt.Println("In two days.")
	default:
		fmt.Println("Too far away.")
	}
}

```

만약 토요일에 본 프로그램을 작동시킨다면 Today가 나올 것이다. 만약 오늘이 토요일이라면 Today가 출력되고 그 아래로 진행하지 않는다.  
또한, default 값도 설정이 가능하다는 것을 알 수 있다.

---

```
조건이 없는 switch는 true와 동일하다.
이 구조는 긴 if-then-else 체인을 쓰는 것보다 깔끔한 방법이 될 수 있다.
```

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Now()
	fmt.Println(t.Hour())	//22
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")	//출력됨
	}
}



```

이 부분이 매우 충격적이고 신선하다. if문을 사용하는 것보다 너무나도 깔끔하다! 사실 switch문은 생각보다 잘 쓰이지 않는 편인데, case가 상수여야 하는 조건이 생각보다 크다. 그런데 case 자리에 t.Hour()과 상수를 비교해서 참이면 출력시키는 참신한 방법으로 코드를 간결하게 만들어 준다.

---

## 지연 실행 (Defer) - Eng ver에만 있음

Defer(지연문)은 함수가 return될 때까지 해당 구문의 실행을 연기합니다. 지연된 호출 인수는 즉시 계산되지만, 함수가 return될 때까지 기다립니다.

```go
package main

import "fmt"

func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}


```

지연 구문은 Java 등에서 finally와 같이 함수 실행 이후 마지막으로 실행되는 구문이다. 해당 함수가 실행을 마칠 때까지 기다리는데, 위 구문에서는 hello가 먼저 출력되고, main이 종료되는 시점에 world를 출력한다.

---

```
지연되는 구문은 Stack에 push된다. LIFO(Last-In-First-Out) 방식으로 꺼내온다.
```

```go
package main

import "fmt"

func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}


```

위 프로그램의 출력 결과는 우선 counting이 출력된다. 후에 0부터 9까지 stack에 쌓이게 되고, done을 출력한다. main이 끝나는 시점에서 stack에서 LIFO로 꺼내오게 되고, 9부터 1까지 역순으로 출력된다.  
이걸 어디에 쓸까 생각해 보았는데, 파일을 열고 작업할 때 어떠한 문제가 생기더라도 미리 close를 걸어두면 파일이 안전하게 닫히지 않을까 추측해 보았다. 즉, 꼭 마무리되어야 할 작업이 있다면 defer를 사용하지 않을까 싶다.

---

읽어주셔서 감사합니다!
